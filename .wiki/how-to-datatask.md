**How To build a BETaaS Data Task**
===================


### BETaaS Data Task  pre requirements

In order to be accessible, Data Tasks, needs to be installed in a gateway where the BETaaS ADS is also isntalled.

Please refer to this guide for ADS details:


### BETaaS components used

In order to run, the BETaaS Data Task needs to retrieve data from DBM Database Services or the Analytic Presto DB source. So either one of these sources must be available and actively collecting data in the
BETaaS instance. Refer to the following installation guide for these components:

## BETaaS Example How to

Implementing a Data Task, requires to impor the following Maven project:

	betaas-service-bigdatamanager-service-datatask

and specifically implements the following interface:

	eu.betaas.service.bigdatamanager.service.datatask
    

##### Interfaces to be implemented by a Data Task


	public TaskInfo getTaskInfo();
	
	public void runTask(HashMap<String,String> input);
	
	public TaskData getTaskData(String taskId);
	
	public boolean taskCompleted(String taskId);

	public void setupTask();
	
	public void removeTask();
    
#### Implementing the getTaskInfo inteface

This interface requires to populate an internal variable of the type TaskInfo with the following information:

- The concrete class implementing this Data Task. Required to identify the type of Data Task when retrieved by the ADS.
- A task description, human readable, which tells the generic purpose of the Data Task.
- The type of database that the task queries, available type are defined by the enum: TaskSource.SQLDATABASE
- The type of task, syncronous (returns immediately response upon running the method run tasks. Or asyncronous if the task data will be available after an certain amount of type this requiring the polling of the taskComplpeted interface. TaskType.SYNCRONOUS
- The type of things data processed TaskDataType is the enum representing the available information.
- The eventual inputList and outputList, two arrays representing a human readable list of input values that are supposed to be provided to the data datask. These description has a struture defined by the class Descriptor. Descriptor("location", FiledDomain.STRING, false, false, "thing location"). This class allows to define the domain, the name of the variable, a human readable description and eventually if the function is mandatory.
    
This class allows to define the characteristics of a Data Task. Once an application request to the ADS, through the Service Manager, the list of available Task. The ADS build a list of TaskInfo resources collected from the available Data Task, by invoking their getTaskInfo interfaces.

#### Implementing the runTask interface

This interface is crucial to the execution of the Data Task. There are two scenarios of runtime for the Data Task, depending on the data sources that are available. 

-	SQL Service Database
-	Analytic Database Presto DB

In case of SQL Service database, the purpose of a data task is to retrieve the most recent data, that are still not stored in the analytic platform, where information are loaded at regular interval but due to resouces contraints, this introduce a lag between the time the data is generated by the thing and the time it arrives inside the Analytic Platform. Moreover, in instances where there is no Analytic platform the data available is collected inside SQL Service databases. For a complete example of Task built over the SQL sources refer to the paragraph below "Building a SQL Service Data Task".
In case there is an analytic platform collecting and processing data coming across the isntance of BETaaS, an Analytic Data Task can be implemented. Refer to the paragraph below "Building an Analytic Data Task".

### Implementing the taskCompleted interface

This inteface can be used for asyncronous Data Task, for these data tasks, the execution time requires a considerable amount of time. FOr this reason, in order to avoiding blocking the calling application, the method, once starde the underlying data task, returns. This method should be used after the runTask method of the Data Task is invoked to learn when the task completed and the data is available.

### Implementing the getTaskData interface

The getTaskData inteface is the one used to retrive the information once the runTask performed the requested task. This method must return data stored in a variable with the type TaskData. 
A TaskData stores results in the following properties:

	taskRunId: the Id of a specific run of this task
	tasktarttime: the time the task started
	actualinput: the original input provided to this task
	taskOutput: an array representing the results
    
    
The task output is a String representing in a JSON format the returned results. It shoudl be conform to the taskOutput descared for TaskInfo associated with this Data Task. In paricutar it can be expected that the results are stored in a JSON array made of elements containin each one as fields, the fields defined in the TaskInfo.

#### Configuring the Service

A Data Task only requires to be configured to export its interface through DOSGi in order to being available to remote gateway. Inside the file *betaas.endpoints.cfg* define the DOSGi service port :
  
    serviceDataTaskCustomddress = http://gatewayIP:DATATASKPORT/dataTaskCustom

#### Installing the Service

To install the service just install the OSGi bundle implementing the Data Task interface on a gateway. Ensure that there are no port conlfict with other published services within the same gateway.

#### Examples available inside the BETaaS platform

To further clarify the Data Task working model, two examples are implemented and available within the BETaaS source code.

##### Building a SQL Service Data Task

This example is available inside the project:

	betaas-service-bigdatamanager-service-datatask

The class implementing the task interface is the DatabaseRecentdataTask.

###### Setup the Data Task to look for SQL Database Services

The most notable points are the method setupTask. This method is called when the OSGi bundle is started and it initialize a service tracker, which tracks the available instance of IDatasourceBDMInterface, the interface of the SQL Service Database. This is required since each time this task is invoked, it runs a query over the existing SQL Service database to retrieve the information to build the response.

	tracker = new ServiceTracker( context, IDatasourceBDMInterface.class.getName(),	null ); 
	tracker.open(); 



###### Creating Information about Data Task

The method buildTaskInfo is called to initialize the internal TaskInfo:

		List<Descriptor> inputList = new ArrayList<Descriptor>(); 
		List<Descriptor> outputList =  new ArrayList<Descriptor>(); 
		outputList.add(new Descriptor("thingID", FiledDomain.STRING, false, false, "Identifier for the thing"));
		outputList.add(new Descriptor("location", FiledDomain.STRING, false, false, "thing location"));
		outputList.add(new Descriptor("measurement", FiledDomain.STRING, false, false, "measurement type"));
		outputList.add(new Descriptor("timestamp", FiledDomain.STRING, false, false, "time of measurement"));
		logger.debug("### tasksimplename  "+DatabaseRecentdataTask.class.getSimpleName());
		taskInfo = new TaskInfo(DatabaseRecentdataTask.class.getSimpleName(),taskDescription, TaskSource.SQLDATABASE, TaskType.SYNCRONOUS, TaskDataType.ALL, inputList, outputList);	

The task publish info that tells us that it return an array of results containing each a field: thingID,location,measurement,timestamp. Results are described as "This task return from the databases service the last reported value for each thing".

###### Building the result of the Data Task

Once the run method is invoked, the Data Task, run a query over each BDM database service.

	Object [] providers = tracker.getServices(); 
		if ( providers != null && providers.length > 0 ) {
			for(int i=0;i<providers.length;i++){
				IDatasourceBDMInterface ibds = (IDatasourceBDMInterface) providers[i];
				response =getFromDataSource(response,ibds.getInfo("").get("url"),
                ibds.getInfo("").get("driver"),ibds.getInfo("").get("user"),ibds.getInfo("").
                get("pwd"),ibds.getInfo("").get("db"));
			}
		}
 
 For each database service it gets a login information and the driver to use to connect. By using this login, it runs a query to collect data:
 
	"SELECT thingID,location,measurement,max(timestamp) from T_THING_DATA GROUP BY thingID,location,measurement ORDER BY thingID";
    
This query is run on each service instance and the results are merged together in a final JSON response that for each thing returns the last time it returned a value and the value returned.


##### Building an Analytic Data Task

This example is available inside the project:

	betaas-examples/betaas-service-bigdatamanager-service-datatask-advanced  


###### Setup the Data Task to use PrestoDB

When running a Data Task against the Analytic platform, a configuration has to be done in order to provide the location of such service. This is provided by the parameters defined inside the *betaas.gateway.cfg* configuration file.

	prestoJdbc = jdbc:presto://betaashadoop:18080/hive/default
	prestoUser = prestoUser
	prestoPwd = prestoPassword

Internally, the Data Task will use the Presto database JDBC driver to connect with the instance of the database. 

##### Building an analytic Data Task

Internally the bundle, load the prestoJDBC drivers:

	Class.forName(prestodrivers);
    
When started, the bundle connects to the database instance specified in the parameters provided:

 	Properties props = new Properties();
	props.setProperty("user", user);
	props.setProperty("password", pwd);
	logger.debug("### Task ready to serve");
	try {
		conn = DriverManager.getConnection(prestoJdbc, props);
	} catch (Exception e) {
		logger.debug("### Task Problem");
		e.printStackTrace();
	}
  


###### Creating Information about Data Task

		List<Descriptor> inputList = new ArrayList<Descriptor>(); 
		List<Descriptor> outputList =  new ArrayList<Descriptor>(); 
		outputList.add(new Descriptor("location", FiledDomain.STRING, false, false, "location"));
		outputList.add(new Descriptor("type", FiledDomain.STRING, false, false, "thing type"));
		outputList.add(new Descriptor("min", FiledDomain.STRING, false, false, "max value"));
		outputList.add(new Descriptor("max", FiledDomain.STRING, false, false, "min value "));
		outputList.add(new Descriptor("avg", FiledDomain.STRING, false, false, "avg value"));
		logger.debug("### tasksimplename  "+PrestoQueryTask.class.getSimpleName());
		taskInfo = new TaskInfo(PrestoQueryTask.class.getSimpleName(),taskDescription,
        TaskSource.NOSQLDATABASE, TaskType.SYNCRONOUS, TaskDataType.ALL, inputList, outputList);	
	
In this case we define the task as: TaskSource.NOSQLDATABASE becasue it runs over the analytic platform.  Moreover the returned data will be available in a JSON array containing elements with the fields: location,type,max,min,avg).

###### Building the result of the Data Task

In order to retrieve the data, the task run an SQL query against the database:

	ResultSet rs = taskDataStmt.executeQuery(TASK_QUERY_AGGREGATE);
    
Results are parsed and provided in a JSON accordingly with the filed defined in the output array.

## About BETaaS Project

#### ** About the consortium**

BETaaS is a STREP Research project developed and co-funded by the European Commission Research and Innovation 7th Framework Program by the [BETaaS Consortium](http://www.betaas.eu/consortium.html#.VEeGuhZvAgk) under the ICT theme (Call 8) of DG CONNECT.

#### ** About BETaaS License**

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at

[http://www.apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0)

Unless required by applicable law or agreed to in writing, software  distributed under the License is distributed on an "AS IS" BASIS,  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and  limitations under the License.


2014 All Rights Reserved by   <font style='color:red'>Fill with partners involved</font>
